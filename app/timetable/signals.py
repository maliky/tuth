from django.db import transaction
from django.db.models import Max
from django.db.models.signals import pre_save, post_save
from django.dispatch import receiver

from django.db.models import F

from app.timetable.models import Section, Reservation
from app.shared.constants import StatusReservation


@receiver(pre_save, sender=Section)
def autoincrement_section_number(sender, instance, **kwargs):
    "to increment section number"
    # autoincrement_section_number() uses select_for_update(), which is good,
    # but you skip the logic when instance.pk is truthy. That is fine for
    # “update” operations, yet a bulk create with Section.objects.bulk_create()
    # will bypass the signal entirely.
    #  → Switch to a database GENERATED BY DEFAULT AS IDENTITY column or a
    # sequence so the DB enforces uniqueness, then expose it as number.
    # database-level CHECK constraints.
    # > what is Truthy ? what does it mean ? trusted ?
    if instance.pk or instance.number:

        return
    with transaction.atomic():
        last = (
            Section.objects.filter(course=instance.course, semester=instance.semester)
            .select_for_update()
            .aggregate(mx=Max("number"))
        )["mx"] or 0
        instance.number = last + 1


@receiver(post_save, sender=Reservation)
def increment_section_count(sender, instance, created, **kwargs):
    """Increment ``current_registrations`` when a reservation is validated."""
    if instance.status != StatusReservation.VALIDATED:
        return
    with transaction.atomic():
        Section.objects.filter(pk=instance.section_id).update(
            current_registrations=F("current_registrations") + 1
        )
